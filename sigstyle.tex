\documentclass{sig-alternate}  
\usepackage{graphicx}
\usepackage{listings}
\usepackage{syntax}
\usepackage{listing}
\lstset{xleftmargin=1em, xrightmargin=1em, breaklines=true, basicstyle=\small, keywordstyle=\bfseries, morekeywords={assert_now, assert_continuously, stop}} 
\usepackage{url}
\usepackage{framed}
\usepackage{amsmath}
\usepackage{authblk}
\usepackage{cite}
\usepackage{verbatim}
\usepackage[]{algorithm2e}

\begin{document}

\title{Joint Optimization of Routing and Node Selection}
\numberofauthors{1} 
\author{
\alignauthor Xuan Kelvin Zou, Yonatan Naamad, Moses Charikar, Jennifer Rexford\\
\affaddr{Princeton University}\\
\email{\{xuanz, ynaamad, moses, jrex\}@cs.princeton.edu}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%                         Abstract                                 %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\begin{abstract} \small\baselineskip=9pt This is the text of my abstract. It is a brief
description of my
paper, outlining the purposes and goals I am trying to address.\end{abstract}
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%                         Intro                                 %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{motivation}
Virtualization has taken widely place and replaced much network functionality, such as virtual switch or middlebox. Middleboxes by nature are suitable for virtualization: unlike switch or router which only requires simple forwarding actions, middleboxes require more advanced functions and not simply just I/O bounded, CPU and memory are often the bottleneck. As the hardware capability keep growing, we will see more virtualized middleboxes are deployed. 

Meantime, Software-Defined Networking (SDN) has emerged as an alternative solution to today's networks. It has several unprecedented advantages: programmable interface for routing behavior, logically centralized view of the network and decoupled control plane and data plane. 

Many studies have been conducted on either fitting traditional middleboxes into SDN network\cite{SIMPLE2013,FLOWTAGS2014}, or virtualizing middlebox functionality in traditional network\cite{ANANTA2013,APLOMB2012}, but can we combine the two solutions together and formulate a better model for today's network? SDN enables more sophisticated routing mechanism and liberates us from picking choke points to place middleboxes, while virtualization enables elasticity and modularity, we can possibly run every middlebox at any physical middlebox server. By exploring the problem, we came up with an audacious design: place middleboxes everywhere, by doing that, we can:
\begin{itemize}
  \item \textbf{Eliminate single point failure of middlebox}
  \newline
  Traditional network meticulously places middlebox at choke point shared by many flow and thus force the traffic to go through. We can avoid the existence of choke point and easier to design a fault tolerant system.
    \item \textbf{Reduce unnecessary bouncing traffic} 
  \newline
  Some networks steer traffic to some middlebox and may add redundant load on the network and extra latency for each flow. We can take advantage of virtualization and placement freedom to reduce unnecessary traffic bouncing. 
  \item \textbf{Ease middlebox policy enforcement}
\newline
Current middlebox policy enforcement is implemented by forcing traffic go through each middlebox, e.g. firewall following proxy is done by force traffic go through firewall first and then proxy. In this system we can simply run different VM instances at the same node and enforce the policy. 
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%                         Design                                 %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{design}
\subsection{Basic Graph Model}
If we review the network abstraction without middleboxes, it is essentially composed of nodes, links and flows. To integrate the middlebox into the graph model, we can think each node attached to a certain number of middleboxes (or attached to a middlebox with a certain amount of processing capacity), so each node has certain processing capacity. In this sense we have a graph with of topology (V,E) with both link bandwidth \textbf{B}(e)where $e \in E(u,v)$ and node capacity \textbf{C}(v)where $v \in V $, and we are trying to fill in traffic demand with both traffic rate demand \textbf{R}(src, dest) and computational work demand \textbf{D}(src, dest). \textbf{R}(src, dest) should be correlated to \textbf{D}(src, dest). Throughout the whole paper, we assume linear relation $q_i = \frac{D}{R}$ for each flow $ i_{src,dst} $right now, which covers most cases, since most middlebox processing is per packet based. The system can achieve a joint optimal outcome for both routing and middlebox usage by coupling routing problem to middlebox placement and middlebox resource allocation problem. This problem could be interpreted at a standard Traffic Engineering problem with a few hard constraints.

\textbf{Hard Constraints}:
\newline
\textbf{B}(e): bandwidth capacity for link e $\in E_{u,v}$
 \newline
\textbf{C}(v): middlebox processing capacity at node v $\in N_{v}$
 \newline
$ \boldsymbol{R}_{i} \text{: flow rate R for } i_{src, dst}$ 
\newline
$ \boldsymbol{D}_{i} \text{: flow middlebox processing demand for } i_{src, dst}$
\newline 
$ q_{i} \text{: ratio of D to R for flow } i_{src, dst}$ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Max Flow }

Notations:

\textbf{B}(e) bandwidth capacity for link e $\in E_{u,v}$ 

\textbf{C}(v) middlebox processing capacity at node v $\in N_{v}$ 

$ f(e) $  flow load at edge e $\in E_{u,v} $ 

$ w(e) $ processing workload demand at node v
$\text{where } e \equiv (u,v) $ 

$p_v $   workload processed at node v
$p_v = \sum\limits_{e \in E_{u, v} } w(e) - \sum\limits_{e \in E_{v, w} } w(e)  $ 


To better understand the graph model, let us start from a simple max flow problem for single source and single destination\cite{FordFulkerson, Edmonds1972}: what is the maximal amount of flow can be pushed along with its processing workload can be processed given the node and link constraints from source to designation.
Here we fix node processing capacity \textbf{C}(v) as known constant constraints. Here without losing generality, we assume workload to flow ratio q=1.
\newline



Optimization Objective:
\newline

Maximize $\sum \limits_{v: (s, v) \in E} f(e) $
\newline

Subject to
\newline
\begin{subequations}
\begin{align}
 &\forall v \in V-{s, t}; \sum\limits_{e \in E_{u, v}}  f(e)= \sum\limits_{e \in E_{v, w} } f(e)\\
&\forall e; f(e)\geq 0,\\
&\forall e; f(e)\leq B(e),\\
&\forall e; w(e) \geq 0,\\
&\forall e; w(e) \leq f(e),\\
&\forall v; p_v\geq 0 ,\\
&\forall v; p_v\leq C(v),\\
&\forall e\in(s, v) ; w(e) =f(e),\\
&\forall e\in(v,t) ; w(e) =0, 
\end{align}
\end{subequations}

If we look closely into the correlation between w and f, here we have (1e) which is saying every time workload can only be carried out by flow, so it should be less than or equal to flow size. There is an alternative way to interpret this problem, that is we have two types of flows, pre-processed and post-processed, and  they are dynamically changing according to workload processed at each node. 

When constructing the dual of a linear program, it is often better to rewrite the problem such that it has a simpler structure, i.e. fewer constraints.\cite{FordFulkerson} And here naturally with the help of equivalence between path-based and edge-based solution, we can formulate the problem in a cleaner way: we can think in terms of the \textit{paths} along which we are going to send the flow rather than how much flow is passing through a specific edge, along the path how much flow processing workload we are going to handle at each hop, instead of how much workload demand left after each hop. However here we cannot simply apply max flow-min cut flow peeling mechanism since we have workload coupled with flow. [See appendix] This makes flow conservation and workload conservation unnecessary. 

\textbf{Notations}:

\begin{tabular} {| l | l |}
\hline
\textbf{B}(e)&bandwidth capacity for link e $\in E_{u,v}$ \\ \hline
\textbf{C}(v)&middlebox processing capacity at node v $\in N_{v}$ \\ \hline
$ f(\pi) $& flow load for path $\pi$ \\ \hline
$ w(\pi, e) $&\begin{tabular} {l} processed workload at node v\\
$\text{where } e \equiv (u,v) $ \\ \end{tabular} \\  \hline
\end{tabular}
\newline

Optimization Objective:
\newline
MInimize $\sum \limits_{\pi\in P} f(\pi)$  
\newline

Subject to
\newline
$\forall e; \sum \limits_{\pi\in P:e\in \pi} f(\pi) \leq B(e)$
\newline
$\forall \pi; \sum \limits_{e\in \pi} w(\pi, e) = f(\pi)$
\newline
$\forall v; \sum \limits_{\pi\in P} \sum \limits_{ e\equiv (u,v)\in \pi} w(\pi, e) \leq C(v)$ \hspace{35 mm} (2)   
\newline
$\forall e; f(e)\geq 0$
\newline
$\forall \pi, e; w(\pi,e) \geq 0$   
\newline

\subsubsection{Understanding the Dual}
Now let us construct the dual of LP(2).\newline

Optimization Objective:
\newline
Minimize $\sum \limits_{e \in E} B(e)* X_e +\sum \limits_{v \in V} C(v)*Y_v $  
\newline

Subject to
\newline
$\sum \limits_{e\in \pi} X_e + Y_v \geq 1$;  \hspace{15 mm} $\forall \pi \in P; \forall e\equiv(u,v)\in \pi  \hspace{11 mm}(3) $ \newline
$\forall e \in E; X_e\geq 0$  \hspace{60 mm} (4)   \newline
$\forall v \in V; Y_v \geq 0$ \hspace{60 mm} (5)  

Similar to a standard Max-Flow/Min-Cut dual problem, we can infer some useful information from the dual math formulation. Let us review the format of dual formulation of Max-Flow/Min-Cut first;

Objective: \newline
Maximize $\sum \limits_{e \in E} B(e)* X_e $  
\newline

Subject to
\newline
$\sum \limits_{e\in \pi} X_e  \geq 1$;  \hspace{35 mm} $\forall \pi \in P\hspace{15 mm}(6)$\newline
$\forall e \in E; X_e\geq 0$\newline

If we look closely into the two different dual formulation, they are actually very similar except that for our problem, we have a new set of variables $Y_v$ and they are also captured in both inequality (3), (4) and objective function. In addition, after we take some insight from node capacity C(v), we can have better understanding of $Y_v$. 
 
We can start from two extreme cases: 

1. if C(v)=0 for $\forall v$, then the objective function should have 0 minimum value, since we can simply have $Y_v\geq 1$ and $X_e=0$ for $\forall v;\forall  e$, so here we can push flow size =0.
 
2. if C(v)=$+\infty$  for $\forall v$, then the objective is the same as min cut, since we will have $Y_v=0$ for $\forall v$ to eliminate the Y term in objective function, so here we can push flow size = $maxflow_{initial}$.

We can relax the constraints for C(v) here: if C(v) is not predefined, instead it could dynamic changing, but total C(v) summed up have to be some certain number, saying $C_{total}$, we can draw some interesting conclusion: we can find a way to allocate node processing capacity at some certain nodes and it will give us provable optimal result. (However optimal allocation is not unique).
\begin{comment}
\begin{algorithm}\label {C(v) Allocation}
\SetAlgoLined
 \KwData{\textit{V, E, $C_{total}$}}
 \KwResult{C(v) for $\forall v$}
\BlankLine
Find the min cut for G(V, E)\;
\emph{ define border node: $\forall v \in set_s$ , where there are edges (v, w) where w $\in set_t$ with B((v, w))>0 }\; 
For all border nodes v from one side of the min cut\;
C(v) = $\frac{ \sum\limits_{<v, w>; w\not\in set_s } B(<v,w>) } {MinCut} * C_{total}$
\caption{C(v) Allocation}
\end{algorithm}
\end{comment}


\begin{comment}
Now let us focus on the case of only one node with C(v)>0. For all paths $\pi$ not going through v, they would simply have no flow since the paths cannot process the flow workload. This would be reflected in  $Y_{v'}\geq 1;\forall v'\in \{V-v\}$, and for all paths where they do go through v, we can reduce that to a Min-Cut problem. The max flow we can send from source to destination is essentially bottlenecked by three constraints: link capacity among links from source to node v, processing capacity at node v and link capacity among links from node v to destination. Here to simplify the math representation in following section, we define function mincut(u) as the max flow from source to destination via paths through node u, so we have min(v)=$min\{mincut(u), C(v)\}$.

Now let us extend this into two nodes $v_1, v_2$ where C($v_1, v_2$)>0,
for all paths $\pi$ not going through either $v_1$ or $ v_2$, they would simply have no flow since the paths cannot process the flow workload. However the max flow for a graph with two nodes would be more complex. As $v_1;v_2$ processing capacity is cumulative, naturally if $v_1$ and $v_2$ are at disjoint paths except source and dest, they are just two separate cases we mentioned above. However we need to consider the correlation between $v_1$ and $v_2$. The combined flow sent through both $v_1$ and $v_2$ cannot exceed the bandwidth total = mincut($v_1,v_2$). So we have min($v_1, v_2$) = $min \{mincut(v_1, v_2), [min(v_1)+min(v_2)]\}$.

Now let us extend the case to three nodes and more:\newline
For three nodes:\newline
min($v_1, v_2, v_3$) = $min \{mincut(v_1, v_2, v_3), min\{[min(v_1, v_2)+min(v_3)],[min(v_1, v_3)+min(v_2)], [min(v_3, v_2)+min(v_1)]\} \}$.
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Flow Size Change}
The model above shows the model where workload processing does not affect the traffic size. However this is not always the case in networking setting, for example, encryption increase the flow size by a little bit via changing either the header or both header and payload\cite{SIMPLE2013}; compression and transcoding decrease the traffic size by up to a factor of two\cite{Mogul1997}. We need to also consider this into our optimization problem.

There have been some work done regarding flow size change in Max flow problems, so called generalized circulation max flow problem.\emph{Wayne, 1999}\cite{Wayne1999}  One thing different in our model is that for pre processed flow handled at that node, the size would be changed, but for post processed flow, it stays the same. So here we need to make some change from the previous LP to make the expression more succinct. 
Now we divide the flow into two categories; processed, and unprocessed. They are represented in $\hat{f}$ and $\bar{f}$. If we compare this with previous LP formulation, $\bar{f} $is essentially w, while $\hat{f}$ = f-w if flow size does not change. 

If there is a size change, at each node, we have $\sum \bar{f}(out) +p(v)=\sum  \bar{f}(in)$ and $\sum \hat{f}(out)=\sum  \hat{f}(in) + p(v)*r; r>0$. (We assume the linear relation between flow size, which satisfy most networking settings) However this way we would violate the flow conservation, that is incoming flow size does not match outgoing flow size anymore. Here to preserve the flow conservation, we can create a transition node which is pointed from all nodes. Physical intuition behind this is that if we have dirty water from source and clean water to water company, and we store clean water at the water company, those sands filtered out from dirty water also has to go to the plant through a different channel to a disposal node. So this transition node has infinity capacity for all links and we can think it as a second destination. It absorbs the flow $\hat{f} =p(v)*(1-r)$ from each node. We call this node disposal node d. Note here r could be greater than 1, in that case $\hat{f}<0$, we can interpret this as injecting from rather than disposing processed flow to d.

Optimization Objective:
\newline
Maximize $\sum \limits_{v: (s, v) \in E} \hat{f}(e) $
\newline

Subject to
\newline
$ \forall v \in V-{s, t, d}; \sum\limits_{e \in E_{u, v}} ( \hat{f}(e) +\bar{f}(e))= \sum\limits_{e \in E_{v, w} } (\hat{f}(e)+ \bar{f}(e))$
\newline
$\forall e; \hat{f}(e)\geq 0$
\newline
$\forall e; \bar{f}(e) \geq 0$
\newline
$\forall e; \hat{f}(e) + \bar{f}(e)\leq B(e)$
\newline
$\forall v;\sum\limits_{e \in E_{u, v}}  \bar{f}(e) - \sum\limits_{e \in E_{v, w} } \bar{f}(e)\geq 0 $ 
\newline
$\forall v; \sum\limits_{e \in E_{u, v}}  \bar{f}(e) - \sum\limits_{e \in E_{v, w} } \bar{f}(e)\leq C(v)$
\newline
$\forall e\in(v, d) ; \hat{f}(e) = (\sum\limits_{e \in E_{u, v}}  \bar{f}(e) - \sum\limits_{e \in E_{v, w} } \bar{f}(e))*(1-r)$
\newline
$\forall e\in (s,v); \hat{f}=0$
\newline
$\forall e\in (v,t); \bar{f}=0$
\newline
$\forall e\in (v,d); \bar{f}=0$
\newline



%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Multiple Commodity Flows with convex function objective}
After exploring the simple max flow model, we can put this in network scenario, and there are two changes in the formulation part:
\begin{enumerate}
\item {It contains more than a single flow}
\item {The objective function is more than simply max flow}
\end{enumerate}

However this does not really change the core of formulation, only changes in objective and adds new intermediate variables like $u(v) $ and $u(e)$.
\newline


\textbf{Notations}:

\begin{tabular} {| l | l |}
\hline
$ f_{i}(e) $&$ \text{flow load for } i_{src,dst} \text{ at edge e } \in E_{u,v} $ \\ \hline
$ w_{i}(e) $&  \begin{tabular} {l}  processing workload demand for flow i at node\\
$ \text{v where } e \equiv (u,v) $ \\ \end{tabular} \\  \hline
$u_{e} $&$ \text{link utilization for edge e }\in \boldsymbol{E}_{u,v}  $ \\ \hline
$p_v(i) $&$ \text{processed at node v from flow i} $ \\ \hline
$u_{v}$&$ \text{middlebox utilization for node v} \in \boldsymbol{N}_{v}$ \\  \hline
\end{tabular}
%%%%%%%%%%%%%%%Optimization problem%%%%%%%%%%%%
\newline

Here we have: 

$u_{e} = \frac{\sum\limits_{i} f_{i}(e) } {B(e)}$ \newline

$u_{v} = \frac{ \sum\limits_{i} p_v(i) } {C(v)} $ \newline 

Here we replace the objective function from Max flow to low utilization of both links and nodes: 
Min $ ( \sum\limits_{v \in N_v} f_1(u_v) +\sum\limits_{e \in E_{u,v}} f_2(u_e) \text{  } )$, where 
$f_1 $ and $f_2$ are convex functions. 
\newline

In addition, since most convex functions heavily penalize utilization if it exceeds 1, we can also remove the link capacity and node capacity constraints. Initial LP might  not be feasible if there is no solution such that no node/link capacity exceeds 1, but this LP can always give feasible solution. 


\subsubsection{Path based model}
In this model, we pick up k best paths based on stretch and link capacity, formulation similar to previous one, but we can add more vectors to keep track of distance.

The advantage is that we can count stretch in an easier way, and the tradeoff is that we give up partial routing freedom, we cannot freely choose any path anymore. 

\begin{framed}
\textbf{Notations}:
\newline

Routing matrix for flow, i at path j through edge e
\newline

$\boldsymbol{H}_i^{j, e} = 
\begin{cases} 
1 & \text{ if edge e is used} \\ 
0 & \text{otherwise} \end{cases} $
\newline

Link matrix for edge e and node v
\newline

$\boldsymbol{E}^{e, v} = 
\begin{cases}
1 & \text{if edge e points to node v} \\
-1 & \text{if edge e points from node v} \\
0 & \text{otherwise}
\end{cases} $
\newline


$f_i^j \text{: flow i sending rate at path j} $
\newline

$w_i^{j, e} \text{: workload processing demand at edge e}$
\newline

$u_(e)\text{: link utilization for edge e } $
\newline

$u_{e} = \frac{\sum\limits_{i}\sum\limits_{j} f_i^j*\boldsymbol{H}_i^{j, e} } {B(e)}$
\newline

middlebox demand processed at node v= incoming workload demand - outgoing workload demand 
\newline

$p_v(i) \text{: processed at node v from flow i} $
\newline

$p_v(i) = \sum\limits_j \sum\limits_e w_i^{j,e}*\boldsymbol{E}^{e,v}  $
\newline

$u_(v) \text{: middlebox utilization for node v}$
\newline

$u_{v} = \frac{ \sum\limits_{i} p_v(i) } {C(v)} $ 
\newline

\end{framed}
%%%%%%%%%%%%%%%Optimization problem%%%%%%%%%%%%

\textbf{Optimization Objective:}
\newline
\newline
Min $ ( \sum\limits_{v \in N_v}f_1(u_v) +\sum\limits_{e \in E_{u,v}}f_2(u_e) \text{  } )$
\newline
\newline
$f_1 $ and $f_2$ are convex functions. 
\newline
\newline

\textbf{Subject to:}
\newline
Flow Conservation for flow i:  
\newline
\newline
$ \forall i, \sum\limits_j f_i^j = D_i $
\newline
\newline
Middlebox workload at node v $\geq$0:
\newline
\newline
$\forall i,v, \text{  }p_v(i)\geq 0 $
\newline
\newline
Middlebox workload demand at e is consistent with flow demand:
\newline
\newline
$\forall i, e, \text{  } w_i^{j,e} \leq q_i * f_i^j$
\newline
\newline
Middlebox worklad demand starting and ending point constraints:
\newline
$ \forall i,j, \text{ } w_i^{j,e}*\boldsymbol{E}^{e,src}  + q_i * f_i^j =0 $
\newline
\newline
$ \forall i,j, \text{ } w_i^{j,e}*\boldsymbol{E}^{e,dst} = 0 $
\newline

\subsection{Demand Inference}
Unlike flow demand, an I/O demanding single resource processing, the demand for middlebox is more complicated. For simplicity we treat middlebox processing as single resource-CPU load. We can simply extend more dimensions of workload to support multiple resources. Through observation, most middlebox processing demand should be a linear to flow rate ($w_i = f_i*q_i+ Constant$) as many processing are per-packet based. For per-flow and per-session based processing, the first packet would require more CPU cycles than following ones, it would be reflected in a greater constant in linear relation. 

In addition, different from middlebox-less network which ensures flow conservation, a middlebox could change the flow rate by compressing or decrypting. We also need to infer that information by separate monitoring. FlowTags \cite{FLOWTAGS2014} can fulfill this mission, however it is heavyweight due to its fine granularity down to each packet, which misaligned with our purpose of measuring traffic pattern. 

\subsection{Traffic Routing Change}




%\bibliographystyle{acm}
%\bibliography{references}


\newpage

\newpage
\appendix

\section{Analysis of Linear Programming Model}
We need to prove that the edge-based LP solution is equivalent to path-based solution. However, unlike the original Max-flow Min-cut problem, this equivalence is not trivial, and we need to show from two sides:
\begin{itemize}
  \item {\textit{Direction A:} If there is a path-based LP solution, we have an edge-based solution.}
  \item {\textit{Direction B:} If there is an edge-based LP solution, we have a path-based solution.}
\end{itemize}

Before we do that, let us make some general observation about the properties of path. The basic requirement for the paths are two folded, along the path f as flow is conserved while w as workload demand is decreasing, and starts with w=f and ends with w=0. However the tricky part about the path is that here we may have valid cycle which we cannot simply use flow cancellation. Or the other way to think about it is that we may deviate the flow to some nodes to "borrow" the node processing capacity, and we can further show that the deviation can happen at most once in the proof.

For \textbf{\textit{Direction A}}, it is easy to show. Once we get a path based solution, we sum up the path-based solution and put it together to a edge-based solution.
\newline
\textit{Proof:}
\newline
For each edge e, $f(e) =\sum\limits_{\pi\in P: e\in \pi} f(\pi)$
\newline
For each node v, $w(e) = \sum\limits_{\pi\in P: e'\in \pi, e' \leq e} w(\pi, e')$ ($\leq$ means e' is topologically at or after e on the path)
\newline
Since flow is built based on path, we have $ \sum\limits_{(u,v)\in E} f(e) $=$ \sum\limits_{\pi\in P, v\in \pi}$ = $\sum\limits_{(v,w )\in E} f(e)$\newline
For each path we also have $w(e) =$ 
$ \sum\limits_{\pi\in P: e'\in \pi, e' \leq e} w(\pi, e')\leq \sum\limits_{\pi\in P: e\in \pi} f(\pi) = f(e)  $\newline

Next we focus on proof for \textbf{\textit{Direction B:}}.

\textbf{\textit{Direction B:}} If there is an edge-based LP solution, we have a path-based solution.

That is, if we have a solution which tells us that if we can assign certain amount of flow and processing 
demand at each edge, we are able to construct paths with a certain amount of flow 
and corresponding processing demand and process workload at every/some node along the path in a certain way. 

Setup:
A set of nodes  v$\in$ V, a set of edges e(u,v)$\in$ E, a flow demand D. We have the solution of from edge-based LP, with 
f(e) is the flow for each edge and w(e) is workload demand at that edge. We also have processing work at each node p(v) and it is simply $p(v) = 
\sum\limits_{e \in E_{u, v} }w_(e) - \sum\limits_{e \in E_{v, w} }w_(e)  $

%\textit{\textbf{Lemma1:} If we have a path with k edges, the upper bound of flow at that path $min(f(e_i)) $  $i\in[1\dots k]$ is achievable}
%\newline
%\textbf{Proof}: Let us think the path is a vector of edges $<e_1, e_2 \dots e_k>$, and among then we have $w(e_1)=f(e_1)$ and $w(e_k)=0$

We first build a graph with all vertices \textit{V}, and for $\forall e(u,v) \in E $, if f(e) >0, we put a direct edge e(u,v) in the graph. We might have cycles or even two flows pointing at the opposite directions. Then we run algorithm\ref{Path Construction} [Path Construction] to get one path to allocate flow. For each flow path, we run flow allocation and update the graph, we exhaustively do it until we place all flow and workload demand, this step is essentially captured in algorithm\ref{Flow Placement} [Flow Placement]. 
\newline


\begin{algorithm}\label {Flow Placement}
\SetAlgoLined
 \KwData{\textit{V, E}, w(e), f(e) for $\forall e \in E$ and p(v) for $\forall v \in V$ }
 \KwResult{f($\pi$), w($\pi$,e) (in which e$\in\pi$) }
\BlankLine
\While{there is one v such that p(v) >0}
{

pick a path $\pi = <e_1, \dots, e_k> $ from Algorithm 2\;
 	$f(\pi) = min( f((e_i) ), \text{ } i\in <1,\dots,k>$\;
	\BlankLine
	w($\pi$)=0\;
	w($\pi, e_k$)=0\;
	\BlankLine
 	\For{$i \leftarrow (k-1)$ \KwTo $1$}
	{
	(u,v)=$e_i$\;
	\emph{//$\delta_i$: workload processed at node i}\;
	$\delta_i = min( p(v), w(e_{i}) , f(\pi) -w(\pi))$\;
	\emph{//Update workload}\;
	$w(\pi, e_i) =\delta_i$\;
	$ w(\pi)= w(\pi)+ \delta_i$\;
	$w(e_i) = w(e_i)- w(\pi)$\;
	$p(v) = p(v)-\delta_i$\;
	$C(v) = C(v) - \delta_i$;
	}
	\BlankLine
	$f(\pi) = w(\pi) $
	\BlankLine
	\emph{//Update flow}\;
	\For{$i \leftarrow (1)$ \KwTo $k$}{
	$f(e_i)=f(e_i)-f(\pi)$\;
	$B(e_i)=B(e_i)-f(\pi)$\;
	}
	
}
\caption{Flow Placement}
\end{algorithm}

\begin{algorithm}\label {Path Construction}
\SetAlgoLined
 \KwData{\textit{V, E}, w(e), f(e) for $\forall e \in E$ and p(v) for $\forall v \in V$ }
 \KwResult{path $\pi$ }
\BlankLine
pick a node v with $p(v)>0$\;
\emph{//Construct path from src->v and v->dest}\;
From v run backward traversal, pick an incoming directed edge with $ max( \rho_{in} )  $ where $\rho_{in} \equiv \frac{ w(e_{in})}{f(e_{in})}$\;
From v run forward traversal, pick an outgoing directed edge with $ min(\rho_{out} ) $ where $\rho_{out} \equiv \frac{ w(e_{out})}{f(e_{out})} $\;
\emph{//See theorem for the reason}\;
\caption{ Path Construction}
\end{algorithm}

%%%%%%%%this is for flow size change%%%%%%%%%%%%%%
\begin{algorithm}\label {Flow Placement}
\SetAlgoLined
 \KwData{\textit{V, E}, w(e), $f^1(e)$, $f^2(e)$ for $\forall e \in E$ and p(v) for $\forall v \in V$ }
 \KwResult{ $f^1$($\pi$, e); $f^2$($\pi$,e), (in which e$\in \pi$) }
\BlankLine
\While{there is one v such that p(v) >0}
{

pick a path $\pi = <e_1, \dots, e_k> $ from path construction\;
	\BlankLine
	pick the node v where p(v)> 0\;
	\emph{//$\hat{e}$: edges topologically before v }\;
	$f^1 (\pi)= min(f^1(\hat{e}))$\;
	\emph{//$\bar{e}$: edges topologically after v }\;
	$f^2 (\pi)= min(f^2(\bar{e}))$\;
	$f(\pi) = min( p(v), f^1(\pi) , \frac {f^2(\pi)}{r} ) $\;
	\For{e $\in \hat{e}$ }
	{
	$f^1(\pi, e) = f(\pi)$\;
	$f^2(\pi, e) = 0$\;
	$f^1(e) = f^1(e) - f^1(\pi, e)$\;
	$B(e)=B(e)-f(\pi)$
	}
	\For{e $\in \bar{e}$ }
	{
	$f^2(\pi, e) = f(\pi)*r$\;
	$f^1(\pi, e) = 0$\;
	$f^2(e) = f^2(e) - f^2(\pi, e)$\;
	$B(e)=B(e)-f(\pi)*r$
	}
	$C(v) = C(v) - f(\pi)$;
}
\caption{Flow Placement}
\end{algorithm}



\begin{algorithm}\label {Path Construction}
\SetAlgoLined
 \KwData{\textit{V, E}, $f^1(e)$,$ f^2(e) $ for $\forall e \in E$ and p(v) for $\forall v \in V$ }
 \KwResult{path $\pi$ }
\BlankLine
pick a node v with $p(v)>0$\;
\emph{//Construct path from src->v and v->dest}\;
From v run backward traversal, pick an incoming directed edge with $ max( \rho_{in} )  $ where $\rho_{in} \equiv \frac{ f^1(e_{in})}{f^1(e_{in})+ f^2(e_{in})/r}$\;
From v run forward traversal, pick an outgoing directed edge with $ min(\rho_{out} ) $ where $\rho_{out} \equiv \frac{  f^1(e_{out})}{f^1(e_{out})+ f^2(e_{out})/r } $\;
\emph{//See theorem for the reason}\;
\caption{ Path Construction}
\end{algorithm}





%%%%%%%%%%%%%                 Third Path Construction                 %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}\label {Flow Placement}
\SetAlgoLined
 \KwData{\textit{V, E}, $f^1(e)$, $f^2(e)$ and $f^3(e)$ for $\forall e \in E$ and $p_a(v)$; $p_b(v)$ for $\forall v \in V$ }
 \KwResult{ $f^1(\pi, e)$; $f^2(\pi,e)$, $f^3(\pi, e)$, (in which e$\in \pi$) }
\BlankLine
\While{there is one v such that $p_a(v)$ >0}
{

pick a path $\pi = <e_1, \dots, e_k> $ and node v and v' from path construction\;

	\emph{//$\hat{e}$: edges topologically before v }\;
	$f^1 (\pi)= min(f^1(\hat{e}))$\;
	\emph{//$\bar{e}$: edges topologically after v'  }\;
	$f^3 (\pi)= min(f^3(\bar{e}))$\;
	\emph{//$\tilde{e}$: edges topologically before v' and after v,$\tilde{e}$ is empty if v=v'}\;
	\uIf{$\tilde{e}$ is empty}
	{
	$f^2 (\pi)=+ \infty$\;
	}
	\uElse{
	$f^2 (\pi)= min(f^2(\tilde{e}))$\;
	}
	$f(\pi) = min( p_a(v), p_b(v'), f^1(\pi) ,  f^2(\pi), f^3(\pi) ) $\;
	
	\For{e $\in \hat{e}$ }
	{
	$f^1(\pi, e) = f(\pi)$\;
	$f^2(\pi, e) = 0$\;
	$f^3(\pi, e) = 0$\;
	$f^1(e) = f^1(e) - f^1(\pi, e)$\;
	$B(e)=B(e)-f(\pi)$
	}
	\For{e $\in \bar{e}$ }
	{
	$f^3(\pi, e) = f(\pi)$\;
	$f^1(\pi, e) = 0$\;
	$f^2(\pi, e) = 0$\;
	$f^3(e) = f^3(e) - f^3(\pi, e)$\;
	$B(e)=B(e)-f(\pi)$
	}
	\For{e $\in \tilde{e}$ }
	{
	$f^1(\pi, e) = 0$\;
	$f^2(\pi, e) = f(\pi)$\;
	$f^3(\pi, e) = 0$\;
	$f^2(e) = f^2(e) - f^2(\pi, e)$\;
	$B(e)=B(e)-f(\pi)$
	}
	
	$C_a(v) = C_a(v) - f(\pi)$\;
	$C_b(v') = C_b(v') - f(\pi)$\;
}
\caption{Flow Placement}
\end{algorithm}


\begin{algorithm}\label {Path Construction}
\SetAlgoLined
 \KwData{\textit{V, E}, $f^1(e)$, $f^2(e)$ and $f^3(e)$ for $\forall e \in E$ and $p_a(v)$; $p_b(v)$ for $\forall v \in V$ }
 \KwResult{path $\pi$ and node v and v' }
\BlankLine
pick a node v with $p_a(v)>0$\;
\uIf{ $p_b(v)>0$}
{
v'=v\;
From v run backward traversal, pick an incoming directed edge with $ max( \rho_1 )  $ \;
From v run forward traversal, pick an outgoing directed edge with $ max(\rho_3 ) $\; }
\uElse
{
From v run backward traversal, pick an incoming directed edge with $ max( \rho_1 )  $ \;
From v run BFS with directed edges where $f^2>0$ to find some node v' where $p_b(v')>0$\;
From node v' forward traversal, pick an outgoing directed edges with $ max(\rho_3 ) $ \;
}
\emph{//See theorem for the reason}\;
\caption{ Path Construction}
\end{algorithm}




We need to prove from two sides for this algorithm: 
\begin{itemize}
  \item {Side 1: there is p(v) >0, we can always find a path with non-zero flow}
   \item {Side 2: after allocation for one path, constraints are held for both this path and the reduced graph} 
\newline
\end{itemize}
Here we introduce an intermediate variable $\rho$ for each edge e where $\rho_{e} = \frac{ w(e)}{f(e)}$.
\newline
\textit{\textbf{Lemma1}: If there is a cycle in the path composition, we can achieve in the cycle there are two edges where  $\rho_{max}= 1$ and $\rho_{min} = 0$. }
\newline
\textbf{Proof}: 
\newline
Proof is similar to flow cancellation in a simpler graph model without workload: 

1. for e=(u,v) whereas $max(\rho_{e})<1$ and thus $w(e) <f(e)$, we can simply cancel the flow demand by small amount $\epsilon$ to the value of workload demand in the loop, and it does not affect the outcome of the flow outside the loop, while we can reduce the flow load in the loop without side effect. 

2. for e=(u,v) whereas $min(\rho_{e})>0$ and thus $w(e) > 0$, we can cancel workload along with flow demand at ratio $q=1$, and this does not affect the outcome of the flow outside of the loop while we can reduce the flow load and workload demand in the loop without side effect. 
\newline
The intuition behind this is that loop exists due to that some flow needs to borrow some processing capacity from some node(s), so it would send a flow with fully unprocessed workload and get back the flow with fully processed workload. 
\newline\newline
\textit{\textbf{Lemma2}: If there is a cycle in a path, $\rho_{max}= 1$ and $\rho_{min} = 0$ are at the the some node and the node is cross point. }
\newline
\textbf{Proof}: 
\newline
\textit{First} There must be one cross point for a cycle exactly. If there are two cross points, then the flow must traverse some edges twice after entering the first node of the two cross nodes. However since links are bidirectional and node processing is neither directional; we can reverse the traffic direction at the first node, so we can avoid loop. 
\newline
\textit{Second} we apply lemma1: there must be two edges in the cycle where one w>0 and the other w=0 based on one $\rho>0$ and the other $\rho=0$. Since for the path, we have w decreasing along the path, so at some node in the cycle we have $w_{n, n'}=0$, then we can follow the w value traverse downstream, until we reach the exit edge pointing to cross point, it also have  $w_{n'',crossPoint}=0->\rho_{out}=0$. \newline
Use the same mechanism, we can prove that $\rho_{crossPoint_{in}}=1$. Since we have flow conservation, so f is the same along the path. Meanwhile we have at some node n where $w_{n,n'} = f_{n, n'}$, and if we traverse upstream we will encounter the entering node pointing from cross point, where we still have $w=f$, since w is decreasing and w is bounded by f. So here we have $\rho_{in}=1$.\newline\newline
\textit{\textbf{Lemma3}: If there is a cycle in a path, there is exactly one cycle and it can only loop at most once }
\newline
\textbf{Proof}: 
\newline
Again we are using the basic requirement for a path, w is decreasing and f is conserved. In this sense, once we are at the cross point of the path from the cycle, we have w=0, where here we cannot go into the same cycle again since it requires some $\rho=1$ which means w>0. Furthermore, we can also eliminate the probability of cycle at downstream path since $\rho=0$. 
\newline\newline
\textit{\textbf{Theorem1}: Our path composition can always generate path with non-zero flow from source to sink. }
\newline
\textbf{Proof}: 
\newline
\textit{First}, based on lemma3, we can split the $cross\text{ } node$ into two nodes while preserving the links, and the traversal at two augmented nodes will pick different incoming and outgoing links due to relations of $\rho$'s  in the algorithm, so we never pick the same node twice from either downstream or upstream traversal, although the two directions may meet at some node along the traversal, and thus it is effectively a DAG. For a DAG we can always reach source and sink.\newline
\textit{Second} we need to show for a certain path $\exists e; w(\pi, e)>0$. Since $\delta = min( p(v),$ $w(e_{i}),f(\pi) -w(\pi,e_{i+1}))$; at node v where p(v)>0; we have $w(e_i)>0$ because $[\rho_{in} =\frac{ w(e_{in})}{f(e_{in})} ]>\rho_{out}\geq 0$. If $\delta=0$ we have $ f(\pi) -w(\pi,e_{i+1}) =0$, which lead to $ w(\pi, e_{i+1})>0$, otherwise $ \delta>0;w(\pi, e_i) = [ \delta+w(\pi, e_{i+1} )]>0$.\newline
\textit{Finally} our algorithm by design conserve the flow and ensures workload demand is decreasing since w is using backward greedy algorithm.
\newline
This essentially proves \textbf{Side 1}.
\newline\newline
\textit{\textbf{Theorem2}: Flow placement algorithm conserves all the constraints for the reduced graph }
\newline
\textbf{Proof}:

For the reduced graph:
\newline
Flow conservation:
\newline
$\forall v,v \in V, v\not\in \pi$; unaffected.
\newline
$\forall v \in \pi; \sum\limits_{e \in E_{u, v}}  f(e) - \sum\limits_{e \in E_{v, w} } f(e)$=
\newline$\sum\limits_{e \in E_{u, v} ; e\not= e_i}  f(e) - \sum\limits_{e \in E_{v, w}; e\not=e_{i+1} } f(e) +[f(e_i)-f(\pi) ] - [f(e_{i+1}) -f(\pi)] = 0 $
\newline
\newline
$ \forall e; \sum\limits_{e=(src, v)} f(e) = \sum\limits_{e=(v, dst)} f(e)$\newline
$[\sum\limits_{e=(src, v), e\not = e_1} f(e) ]+f^{new}(e_1)= [\sum\limits_{e=(v, dst), e\not = e_k} f(e) ]+ f^{new}(e_k)$\newline
$[\sum\limits_{e=(src, v), e\not = e_1} f(e) ]+f(e_1) -f(\pi)$\newline
$= [\sum\limits_{e=(v, dst), e\not = e_k} f(e) ]+ f(e_k)-f(\pi)$\newline
$=D-f(\pi) = D^{new} $
\newline
Middlebox workload at nodes:\newline
$\forall v ,v\in V, v \not\in \pi;$ unaffected.\newline
$\forall v \in \pi$\newline
$  \delta = min\{p(v), [w(e_{i+1}) - w(e_i)],[ f(\pi) -w(\pi,e_{i+1})]\}\leq p(v);$\newline
$ p^{new}(v)=p(v) -\delta  \geq 0;$\newline
Middlebox demand consistent with flow demand\newline
$\forall e \not \in \pi;$ unaffected. \newline
$\forall e \in \pi:$\newline
Prove the right side inequality: $f^{new}(e) = f(e)-f(\pi)= f(e)-w(\pi,e) \geq w(e)-w(\pi,e) = w^{new}(e)$ \newline
Prove the left side inequality: $\forall i \in <1, \dots k>;$ we have $ w(\pi, e_i) \leq w(e_i) -w(e_{i+1});$ so $w^{new}(e_i) = w(e_i)-w(\pi, e_i) \geq w(e_i)- min(w(e_i)) \geq 0$.\newline
Middlebox demand at starting and ending points:\newline
$\forall e, e =(src, v), e\not = e_1$; unaffected\newline
For $ e=e_1, w^{new}(e_1) = w(e_1)-w(\pi, e_1) = f(e_1)-f(\pi) =f^{new}(e_1)$\newline
$\forall e, e =(v, dst), e\not = e_k$; unaffected\newline
For $ e=e_1, w^{new}(e_k) = w(e_k)-w(\pi, e_k) = f(e_k)-0 =0$
\newline
This essentially proves \textbf{Side 2}.


\end{document}
